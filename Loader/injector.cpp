bool EnableDebugPrivilege(bool bEnable)
{
	HANDLE hToken = nullptr;
	LUID luid;

	if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &hToken)) return false;
	if (!LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &luid)) return false;

	TOKEN_PRIVILEGES tokenPriv;
	tokenPriv.PrivilegeCount = 1;
	tokenPriv.Privileges[0].Luid = luid;
	tokenPriv.Privileges[0].Attributes = bEnable ? SE_PRIVILEGE_ENABLED : 0;

	if (!AdjustTokenPrivileges(hToken, FALSE, &tokenPriv, sizeof(TOKEN_PRIVILEGES), NULL, NULL)) return false;

	return true;
}

DWORD getPIDbyName(const TCHAR *procname)
{
	/*
	ERROR LIST
	-1 - Success but couldn't find that process
	0 - Success!
	1 - Can't snap system (admin rights?)
	2 - Can't read snap (Low memory?)
	
	*/

	//Init some stuff
	HANDLE tmpHandle = NULL;
	bool b;
	
	//Handle to store the snapshot
	HANDLE systemSnap;
	//Initialize to every process dump (no heap nor modules)
	systemSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
	if (systemSnap==INVALID_HANDLE_VALUE)
	{
		//std::wcout << "Can't snap system" << std::endl;
		return 1;
	}
	
	//We have our snapshot, we need to enumerate every process (get its ID)
	//A custom handle to store process data
	PROCESSENTRY32 procHandler;
	//Initialize dwSize so Process32First won't fail
	procHandler.dwSize = sizeof(PROCESSENTRY32);
	//We are ready to call Process32First
	Process32First(systemSnap, &procHandler);
	//Got our first process, now, dump it's ID and ExeFile
	//processPath = procHandler.szExeFile; //Exe Path
	//processId   = procHandler.th32ProcessID; //PID
	
	//The first item in the list is the system IDLE which is unaccesible to us and useless 
	while(1)
	{
		//The process wasn't the one we were looking for, look next
		b = Process32Next(systemSnap, &procHandler);
		if (!b) //if b==false
		{/*throw(proc_not_found);*/
			return 2;
		} 
		else
		{
			if (strcmp(procHandler.szExeFile,procname)==0)
			{
				return procHandler.th32ProcessID;
			}
			else
			{
				return -1;
			}	
		}
	}	

	//Deletes snapshot and tmpHandle
	CloseHandle(systemSnap);
	CloseHandle(tmpHandle);
	return 0;
	
}

int RemoteThread(DWORD procID, LPCSTR dllpath) //pointer to the dll path string
{
	DWORD pathSize = strlen(dllpath) + 1; //Calculates the lenght of the string + 1 (the null terminator!)
	std::cout << "Path Size: " + pathSize << std::endl;
	//Now the handle using OpenProcess with the ID
	HANDLE target;
	target = OpenProcess(PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ, FALSE, procID);
	if (target == NULL){ return false; }
	std::cout << "[>]Process Opened." << std::endl;

	//Next, Allocate memory on the process virtual memory
	LPVOID allocMem; //Pointer to our allocated memory address
	allocMem = VirtualAllocEx(target, NULL, pathSize, MEM_COMMIT, PAGE_READWRITE);
	std::cout << "[>]Memory Allocated." << std::endl;

	//Afterwards we'll write the dll path to the memory
	int x = WriteProcessMemory(target, allocMem, dllpath, pathSize, NULL);
	if (x == 0){ return false; }
	std::cout << "[>]Dll Path Wroten." << std::endl;

	//Now, we are going to create a new thread, which will start on LoadLibraryA and its (only) parameter will be the dll path(which is avaiable inside the targets vritual memory since we have write it there)
	//LoadLibraryA is in kernell32.dll which is ALWAYS loaded at init in EVERY windows binary (exe) which is run so it shall be avaiable
	HMODULE k32 = GetModuleHandle("kernel32.dll"); //Handle of type HMODULE to kernell32.dll 
	LPVOID LoadLibraryA = GetProcAddress(k32, "LoadLibraryA"); //Address of type FARPROC (actually this is standard pointer :D, so LPVOID does the job)
	std::cout << "[>]Kernel32&LoadLibraryA resolved." << std::endl;

	//Create the remote thread which will inmediately run LoadLibraryA with parameter allocMem (dll path)
	HANDLE newThread;
	newThread = CreateRemoteThread(target, NULL, 0, (LPTHREAD_START_ROUTINE)LoadLibraryA, allocMem, 0, NULL);
	//Now we wait until the new remotethread ends
	WaitForSingleObject(newThread, INFINITE);
	std::cout << "[>]Thread Returned." << std::endl;
	//So it has ended, let's clean this 
	CloseHandle(newThread);
	FreeLibrary(k32);
	VirtualFreeEx(target, allocMem, 0, MEM_RELEASE);
	CloseHandle(target);
	return 0;

}