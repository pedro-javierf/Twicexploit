bool EnableDebugPrivilege(bool bEnable)
{
	HANDLE hToken = nullptr;
	LUID luid;

	if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &hToken)) return false;
	if (!LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &luid)) return false;

	TOKEN_PRIVILEGES tokenPriv;
	tokenPriv.PrivilegeCount = 1;
	tokenPriv.Privileges[0].Luid = luid;
	tokenPriv.Privileges[0].Attributes = bEnable ? SE_PRIVILEGE_ENABLED : 0;

	if (!AdjustTokenPrivileges(hToken, FALSE, &tokenPriv, sizeof(TOKEN_PRIVILEGES), NULL, NULL)) return false;

	return true;
}

DWORD getPIDbyName(std::string procName){
   HANDLE hsnap;
   PROCESSENTRY32 pt;
   hsnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
   pt.dwSize = sizeof(PROCESSENTRY32);
   do{
          if(!strcmp(pt.szExeFile, procName.c_str())){
             DWORD pid = pt.th32ProcessID;
             CloseHandle(hsnap);
             return pid;
          }
   } while(Process32Next(hsnap, &pt));
   CloseHandle(hsnap);
   return 0;          
}

int RemoteThread(DWORD procID, LPCSTR dllpath) //pointer to the dll path string
{
	DWORD pathSize = strlen(dllpath) + 1; //Calculates the lenght of the string + 1 (the null terminator!)
	std::cout << "Path Size: " + pathSize << std::endl;
	//Now the handle using OpenProcess with the ID
	HANDLE target;
	target = OpenProcess(PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ, FALSE, procID);
	if (target == NULL){ return false; }
	std::cout << "[>]Process Opened." << std::endl;

	//Next, Allocate memory on the process virtual memory
	LPVOID allocMem; //Pointer to our allocated memory address
	allocMem = VirtualAllocEx(target, NULL, pathSize, MEM_COMMIT, PAGE_READWRITE);
	std::cout << "[>]Memory Allocated." << std::endl;

	//Afterwards we'll write the dll path to the memory
	int x = WriteProcessMemory(target, allocMem, dllpath, pathSize, NULL);
	if (x == 0){ return false; }
	std::cout << "[>]Dll Path Wroten." << std::endl;

	//Now, we are going to create a new thread, which will start on LoadLibraryA and its (only) parameter will be the dll path(which is avaiable inside the targets vritual memory since we have write it there)
	//LoadLibraryA is in kernell32.dll which is ALWAYS loaded at init in EVERY windows binary (exe) which is run so it shall be avaiable
	HMODULE k32 = GetModuleHandle("kernel32.dll"); //Handle of type HMODULE to kernell32.dll 
	LPVOID LoadLibraryA = GetProcAddress(k32, "LoadLibraryA"); //Address of type FARPROC (actually this is standard pointer :D, so LPVOID does the job)
	std::cout << "[>]Kernel32&LoadLibraryA resolved." << std::endl;

	//Create the remote thread which will inmediately run LoadLibraryA with parameter allocMem (dll path)
	HANDLE newThread;
	newThread = CreateRemoteThread(target, NULL, 0, (LPTHREAD_START_ROUTINE)LoadLibraryA, allocMem, 0, NULL);
	//Now we wait until the new remotethread ends
	WaitForSingleObject(newThread, INFINITE);
	std::cout << "[>]Thread Returned." << std::endl;
	//So it has ended, let's clean this 
	CloseHandle(newThread);
	FreeLibrary(k32);
	VirtualFreeEx(target, allocMem, 0, MEM_RELEASE);
	CloseHandle(target);
	return 0;

}